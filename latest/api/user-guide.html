<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Generate AES-256 encrypted private key</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">buddy-core</span> <span class="project-version">1.7.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-introduction.html"><div class="inner"><span>Introduction</span></div></a></li><li class="depth-1 "><a href="01-hash.html"><div class="inner"><span>Hash algorithms (digest)</span></div></a></li><li class="depth-1 "><a href="02-mac.html"><div class="inner"><span>MAC algorithms</span></div></a></li><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>Generate AES-256 encrypted private key</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buddy</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3 branch"><a href="buddy.core.bytes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bytes</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.certificates.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>certificates</span></div></a></li><li class="depth-3"><a href="buddy.core.codecs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codecs</span></div></a></li><li class="depth-4"><a href="buddy.core.codecs.base64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.crypto.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>crypto</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.dsa.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dsa</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.hash.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hash</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.kdf.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kdf</span></div></a></li><li class="depth-3"><a href="buddy.core.keys.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>keys</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jwk</span></div></div></li><li class="depth-5 branch"><a href="buddy.core.keys.jwk.ec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ec</span></div></a></li><li class="depth-5 branch"><a href="buddy.core.keys.jwk.eddsa.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>eddsa</span></div></a></li><li class="depth-5 branch"><a href="buddy.core.keys.jwk.okp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>okp</span></div></a></li><li class="depth-5 branch"><a href="buddy.core.keys.jwk.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-5"><a href="buddy.core.keys.jwk.rsa.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rsa</span></div></a></li><li class="depth-4"><a href="buddy.core.keys.pem.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>pem</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.mac.html"><div class="inner"><span class="tree" style="top: -238px;"><span class="top" style="height: 247px;"></span><span class="bottom"></span></span><span>mac</span></div></a></li><li class="depth-3 branch"><a href="buddy.core.nonce.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nonce</span></div></a></li><li class="depth-3"><a href="buddy.core.padding.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>padding</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><p>== Keys</p>
<p>=== Reading PEM formatted keys</p>
<p>Before explaining digital signatures, you need to read public/private keypairs and convert them to usable objects. Buddy has limited support for reading:</p>
<ul>
  <li>RSA keypair</li>
  <li>ECDSA keypair</li>
</ul>
<p>==== RSA Keypair</p>
<p>An RSA keypair is obviously used for RSA encryption/decryption, but it is also used for making digital signatures with RSA-derived algorithms.</p>
<p>.Read keys</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source,clojure]</h2>
<p>(require ’[buddy.core.keys :as keys])</p>
<p>;; The last parameter is optional and is only mandatory ;; if a private key is encrypted. (def privkey (keys/private-key “test/_files/privkey.3des.rsa.pem” “secret”)</p>
<h2><a href="#def-pubkey-keys-public-key-test-files-pubkey-3des-rsa-pem-" name="def-pubkey-keys-public-key-test-files-pubkey-3des-rsa-pem-"></a>(def pubkey (keys/public-key “test/_files/pubkey.3des.rsa.pem”))</h2>
<p>.Generate a RSA Keypair using openssl.</p>
<h2><a href="#source-bash" name="source-bash"></a>[source,bash]</h2>
<h1><a href="#generate-aes-256-encrypted-private-key" name="generate-aes-256-encrypted-private-key"></a>Generate AES-256 encrypted private key</h1>
<p>openssl genrsa -aes256 -out privkey.pem 2048</p>
<h1><a href="#generate-public-key-from-previously-created-private-key-" name="generate-public-key-from-previously-created-private-key-"></a>Generate public key from previously created private key.</h1>
<h2><a href="#openssl-rsa-pubout-in-privkey-pem-out-pubkey-pem" name="openssl-rsa-pubout-in-privkey-pem-out-pubkey-pem"></a>openssl rsa -pubout -in privkey.pem -out pubkey.pem</h2>
<p>==== ECDSA Keypair</p>
<p>Like RSA keypairs, ECDSA is also used for making digital signatures and can be read like in the RSA examples.</p>
<p>.Read keys.</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.keys :as keys])</p>
<p>;; The last parameter is optional and is only mandatory ;; if a private key is encrypted. (def privkey (keys/private-key “test/_files/privkey.ecdsa.pem” “secret”)</p>
<h2><a href="#def-pubkey-keys-public-key-test-files-pubkey-ecdsa-pem-" name="def-pubkey-keys-public-key-test-files-pubkey-ecdsa-pem-"></a>(def pubkey (keys/public-key “test/_files/pubkey.ecdsa.pem”))</h2>
<p>.Generate a ECDSA Keypair using openssl.</p>
<h2><a href="#source-bash" name="source-bash"></a>[source, bash]</h2>
<h1><a href="#generate-a-params-file" name="generate-a-params-file"></a>Generate a params file</h1>
<p>openssl ecparam -name prime256v1 -out ecparams.pem</p>
<h1><a href="#generate-a-private-key-from-params-file" name="generate-a-private-key-from-params-file"></a>Generate a private key from params file</h1>
<p>openssl ecparam -in ecparams.pem -genkey -noout -out ecprivkey.pem</p>
<h1><a href="#generate-a-public-key-from-private-key" name="generate-a-public-key-from-private-key"></a>Generate a public key from private key</h1>
<h2><a href="#openssl-ec-in-ecprivkey-pem-pubout-out-ecpubkey-pem" name="openssl-ec-in-ecprivkey-pem-pubout-out-ecpubkey-pem"></a>openssl ec -in ecprivkey.pem -pubout -out ecpubkey.pem</h2>
<p><a href="buddy.core.keys.html#var-jwk">jwk</a> === Json Web Key (JWK)</p>
<p>A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key of different types.</p>
<p><em>buddy-core</em> provides functions for reading and saving JCA keys in JWK format</p>
<p>Currently supported JWK key types are</p>
<ul>
  <li>RSA key pairs (No RSA-CRT support yet)</li>
  <li>OKP key pairs (Ed25519)</li>
  <li>EC key pairs (P-256, P-384, P-521 curves)</li>
</ul>
<p>Example of JWS signing for Ed25519 keys</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.keys :as keys])</p>
<p>(def edkey {:kty “OKP”,  :crv “Ed25519”,  :d “nWGxne_9WmC6hEr0kuwsxERJxWl7MmkZcDusAxyuf2A”,  :x “11qYAYKxCrfVS_7TyWQHOg7hcvPapiMlrwIaaPcHURo”})</p>
<h2><a href="#def-privkey-keys-jwk-private-key-edkey-" name="def-privkey-keys-jwk-private-key-edkey-"></a>(def privkey (keys/jwk-&gt;private-key edkey))</h2>
<p>You can also convert from PEM to JWK like this</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.keys :as keys])</p>
<p>(def prv (keys/private-key “private.pem”)) (def pub (keys/public-key “public.pem”))</p>
<p>;; JWK requires both public and private keys for export (def jwk (keys/jwk prv pub))</p>
<h2><a href="#def-jwk-pub-keys-public-key-jwk-pub-" name="def-jwk-pub-keys-public-key-jwk-pub-"></a>(def jwk-pub (keys/public-key-&gt;jwk pub))</h2>
<p><a href="null">ed25519-generation</a>You can generate and save keys in JWK format like this</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source,clojure]</h2>
<p>(require ’[buddy.core.keys :as keys]) (import ’java.security.KeyPairGenerator) (import ’java.security.SecureRandom)</p>
<p>(defn generate-keypair-ed25519  []  (let [kg (KeyPairGenerator/getInstance “EdDSA” “EdDSA”)]  (.initialize kg  256  ;; JDK8 only, use getInstance on JDK7 (make sure it’s true random source)  (SecureRandom/getInstanceStrong))  (.genKeyPair kg)))</p>
<p>(let [pair (generate-keypair-ed25519)]  (keys/jwk (.getPrivate pair) (.getPublic pair)))</p>
<p>;; =&gt; ;; {:kty “OKP”, ;; :crv “Ed25519”, ;; :d “5q3yhCdSDMj9Za9jJE0vhfExlTV8JeSe6XnfblAFkPY”,</p>
<h2><a href="#x-jbbhb16saghhighx3futvmfvtgu9-sctzgfzyodzsbq-" name="x-jbbhb16saghhighx3futvmfvtgu9-sctzgfzyodzsbq-"></a>;; :x “JbbhB16SaghHiGHx3FutVMfVTgu9-SCtZGfZyoDZSbQ”}</h2>
<p>You can also calculate JWK thumbprint using <code>jwk-thumbprint</code> function</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source,clojure]</h2>
<p>(require ‘[buddy.core.keys :as keys]) (require ’[buddy.core.codecs :as codecs])</p>
<p>(def edkey {:kty “OKP”,  :crv “Ed25519”,  :d “nWGxne_9WmC6hEr0kuwsxERJxWl7MmkZcDusAxyuf2A”,  :x “11qYAYKxCrfVS_7TyWQHOg7hcvPapiMlrwIaaPcHURo”})</p>
<p>(-&gt; (keys/jwk-thumbprint edkey)  (codecs/bytes-&gt;hex))</p>
<h2><a href="#90facafea9b1556698540f70c0117a22ea37bd5cf3ed3c47093c1707282b4b89" name="90facafea9b1556698540f70c0117a22ea37bd5cf3ed3c47093c1707282b4b89"></a>;; =&gt; “90facafea9b1556698540f70c0117a22ea37bd5cf3ed3c47093c1707282b4b89”</h2>
<p>== Digital Signatures</p>
<p>Digital Signature algorithms has similar purposes that MAC but comes with some tradeoffs such as them provides additional security feature (Non-repudiation) with cost in the performance. You can read a great explanation about the differences with MAC link:<a href="http://crypto.stackexchange.com/a/5647[here]">http://crypto.stackexchange.com/a/5647[here]</a>.</p>
<p><em>buddy-core</em> comes with support for: link:<a href="https://en.wikipedia.org/wiki/PKCS_1[rsassa-pss]">https://en.wikipedia.org/wiki/PKCS_1[rsassa-pss]</a>, link:<a href="https://en.wikipedia.org/wiki/PKCS_1[rsassa-pkcs">https://en.wikipedia.org/wiki/PKCS_1[rsassa-pkcs</a>] and link:<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm[ecdsa]">https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm[ecdsa]</a>.</p>
<p>.Example signing string using rsassa-pss+sha256</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.keys :as keys]) (require ’[buddy.core.dsa :as dsa])</p>
<p>;; Read private key (def privkey (keys/private-key “test/_files/privkey.3des.rsa.pem” “secret”))</p>
<p>;; Make signature (def signature (dsa/sign “foo” {:key privkey :alg :rsassa-pss+sha256}))</p>
<h2><a href="#now-signature-contains-a-byte-with-signature-of-foo-string" name="now-signature-contains-a-byte-with-signature-of-foo-string"></a>;; Now signature contains a byte[] with signature of “foo” string</h2>
<p>.Example verifying signature</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>;; Read public key (def pubkey (keys/public-key “test/_files/pubkey.3des.rsa.pem”))</p>
<p>;; Make verification (dsa/verify “foo” signature {:key pubkey :alg :rsassa-pss+sha256})</p>
<h2><a href="#true" name="true"></a>;; =&gt; true</h2>
<p>Here is a table with complete list of supported algorithms and its variants:</p>
<p>[options=“header”, cols=“1,3”] |=============================================== | Algorithm name | <code>:alg</code> keyword value | RSASSA-PSS | <code>:rsassa-pss+sha256</code>, <code>:rsassa-pss+sha384</code>, <code>:rsassa-pss+sha512</code> | RSASSA-PKCS 1.5 | <code>:rsassa-pkcs15+sha256</code>, <code>:rsassa-pkcs15+sha384</code>, <code>:rsassa-pkcs15+sha512</code> | ECDSA | <code>:ecdsa+sha256</code>, <code>:ecdsa+sha384</code>, <code>:ecdsa+sha512</code> |===============================================</p>
<p>NOTE: <em>ECDSA</em> algorithm requires EC type of asymentric key pair.</p>
<p>== Key Derivation Functions (KDF)</p>
<p>Key derivation functions are often used in conjunction with non-secret parameters to derive one or more keys from a common secret value.</p>
<p><em>buddy</em> commes with several of them:</p>
<p>.Supported key derivation functions. [options=“header”, cols=“1,3,2”] |============================================================================== | Name | <code>:alg</code> value | Description | HKDF | <code>:hkdf+sha256</code>, <code>:hkdf+sha384</code>, <code>:hkdf+sha512</code> | HMAC-based Extract-and-Expand Key Derivation Function | KDF1 | <code>:kdf1+sha256</code>, <code>:kdf1+sha384</code>, <code>:kdf1+sha512</code> | KDF v1 | KDF2 | <code>:kdf2+sha256</code>, <code>:kdf2+sha384</code>, <code>:kdf2+sha512</code> | KDF v2 | CMKDF | <code>:cmkdf+sha256</code>, <code>:cmkdf+sha384</code>, <code>:cmkdf+sha512</code> | Counter-Mode key derivation function (as defined in NIST SP800-108) | FMKDF | <code>:fmkdf+sha256</code>, <code>:fmkdf+sha384</code>, <code>:fmkdf+sha512</code> | Feedback-Mode key derivation function (as defined in NIST SP800-108) | DPIMKDF | <code>:dpimkdf+sha256</code>, <code>:dpimkdf+sha384</code>, <code>:dpimkdf+sha512</code> | Double-Pipeline Iteration Mode key derivation function (as defined in NIST SP800-108) | PBKDF2 | <code>:pbkdf2+sha256</code>, <code>:pbkdf2+sha384</code>, <code>:pbkdf2+sha512</code> | Password-Based Key Derivation Function 2 (a.k.a. <code>RSA PKCS #5 v2.0</code>, also published in RFC 2898) |==============================================================================</p>
<p>.Example using KDF with HKDF key derivation function</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.codecs :as codecs]) (require ’[buddy.core.kdf :as kdf])</p>
<p>;; Using hkdf derivation functions. It requires a ;; key, salt and optionally info field that can ;; contain any random data.</p>
<p>(def hkdf (kdf/engine {:alg :hkdf+sha256  :key “mysecret”  :salt “mysalt”}))</p>
<p>(-&gt; (kdf/get-bytes hkdf 8)  (codecs/bytes-&gt;hex)) ;; =&gt; “0faba553152fce4f”</p>
<p>;; Or using different digest algorithm:</p>
<p>(def hkdf (kdf/engine {:alg :hkdf  :digest :blake2b-512  :key “test”  :salt “test”}))</p>
<p>(-&gt; (kdf/get-bytes hkdf 8)  (codecs/bytes-&gt;hex))</p>
<h2><a href="#9d22728d54e549a6" name="9d22728d54e549a6"></a>;; =&gt; “9d22728d54e549a6”</h2>
<p>.Example using PBKDF2 with sha256</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(def pbkdf2 (kdf/engine {:key “my password”  :salt (nonce/random-bytes 8)  :alg :pbkdf2  :digest :sha256  :iterations 1}))</p>
<p>(-&gt; (kdf/get-bytes pbkdf2 8)  (codecs/bytes-&gt;hex)) ;; =&gt; “26606ebf3a4bb4b3”</p>
<hr />
<h1><a href="#warning" name="warning"></a>[WARNING]</h1>
<p>PBKDF2 works slightly different to the rest of KDF implementations. You should pass the number of iterations explicltly and <code>get-bytes</code> always returns the same value in contrast to the others where <code>get-bytes</code> works as consumer of infinite stream.</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>;; Note the same output for multiple requests:</p>
<p>(-&gt; (kdf/get-bytes pbkdf2 8)  (codecs/bytes-&gt;hex)) ;; =&gt; “26606ebf3a4bb4b3”</p>
<p>(-&gt; (kdf/get-bytes pbkdf2 8)  (codecs/bytes-&gt;hex)) ;; =&gt; “26606ebf3a4bb4b3”</p>
<p>;; Note that each request returns the next ;; bytes of the stream:</p>
<p>(-&gt; (kdf/get-bytes hkdf 8)  (codecs/bytes-&gt;hex)) ;; =&gt; “d42edcfc40c860ce”</p>
<p>(-&gt; (kdf/get-bytes hkdf 8)  (codecs/bytes-&gt;hex))</p>
<h2><a href="#353ce2240159c094" name="353ce2240159c094"></a>;; =&gt; “353ce2240159c094”</h2>
<p>====</p>
<h1><a href="#warning" name="warning"></a>[WARNING]</h1>
<p>This is a <em>low-level</em> kdf primitive and if you want a password hasher, please use</p>
<h1><a href="#module-instead-of-this-" name="module-instead-of-this-"></a><code>buddy-hashers</code> module instead of this.</h1>
<p>== Ciphers</p>
<p>Ciphers support in buddy is available on <code>buddy.core.crypto</code> namespace.</p>
<p>=== Block Ciphers</p>
<p>In cryptography, a block cipher is a deterministic algorithm operating on fixed-length groups of bits, called blocks, with an unvarying transformation that is specified by a symmetric key.</p>
<p>.This is a list of currently supported block ciphers in buddy [options=“header”] |======================================== |Algorithm name | Keywords | AES | <code>:aes</code> | Twofish | <code>:twofish</code> | Blowfish | <code>:blowfish</code> |========================================</p>
<p>Additionally, for good security, is mandatory to combine a block cipher with some cipher mode of operation.</p>
<p>.This is a list of currently supported of cipher mode of operation [options=“header”] |======================================== |Algorithm name | Keywords | SIC (CTR) | <code>:ctr</code>, <code>:sic</code> | CBC | <code>:cbc</code> | OFB | <code>:ofb</code> | GCM | <code>:gcm</code> |========================================</p>
<p>NOTE: currently buddy comes with limited number of ciphers and modes, but in near future more many more options should be added.</p>
<p>.Example encrypt</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.crypto :as crypto]) (require ’[buddy.core.nonce :as nonce]) (require ’[buddy.core.codecs :as codecs])</p>
<p>(let [eng (crypto/block-cipher :twofish :cbc)  iv16 (nonce/random-nonce 16)  key32 (nonce/random-nonce 32)  data (codecs/hex-&gt;bytes “000000000000000000000000000000AA”)]  (crypto/init! eng {:key key32 :iv iv16 :op :encrypt})  (crypto/process-block! eng data))</p>
<h2><a href="#byte-" name="byte-"></a>;; =&gt; #&lt;byte[] [<a href="mailto:B@efadff9">B@efadff9</a></h2>
<p>AEAD mode of operations also exposes additional function for caluclate the total size of the output including the authentication tag: <code>output-size</code>.</p>
<p>=== Stream Ciphers</p>
<p>Stream ciphers differ from block ciphers, in that they works with arbitrary length input and do not require any additional mode of operation.</p>
<p>.This is a list of currently supported of stream ciphers in buddy [options=“header”] |======================================== |Algorithm name | Keywords | ChaCha | <code>:chacha</code> |========================================</p>
<p>.Example encrypt</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.crypto :as crypto]) (require ’[buddy.core.codecs :as codecs]) (require ’[buddy.core.nonce :as nonce])</p>
<p>(let [eng (crypto/stream-cipher :chacha)  iv8 (nonce/random-nonce 8)  key32 (nonce/random-nonce 32)  data (codecs/hex-&gt;bytes “0011”)]  (crypto/init! eng {:key key32 :iv iv8 :op :encrypt})  (crypto/process-bytes! eng data))</p>
<h2><a href="#byte-" name="byte-"></a>;; =&gt; #&lt;byte[] [<a href="mailto:B@efadff9">B@efadff9</a></h2>
<p>NOTE: the iv and key size depends estrictly on cipher engine, in this case, chacha engine requires 8 bytes iv.</p>
<p>NOTE: for decrypt, only change <code>:op</code> value to <code>:decrypt</code></p>
<p>You can call <code>crypto/initialize!</code> any times as you want, it simply reinitializes the engine.</p>
<p>=== High level encryption schemes</p>
<p>Since version 0.6.0, <em>buddy-core</em> comes with high level crypto interface that allows user encrypt arbitrary length data using one of the well established encryption schemes.</p>
<p>The api consists in two simple functions. Let see an example of how to encrypt arbitrary length text and decrypt it:</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.crypto :as crypto]) (require ’[buddy.core.codecs :as codecs]) (require ‘[buddy.core.nonce :as nonce]) (require ’[buddy.core.hash :as hash])</p>
<p>(def original-text  (codecs/to-bytes “Hello World.”))</p>
<p>(def iv (nonce/random-bytes 16)) ;; 16 bytes random iv (def key (hash/sha256 “mysecret”)) ;; 32 bytes key</p>
<p>;; Encrypt the original-text content using previously ;; declared iv and key. (def encrypted (crypto/encrypt original-text key iv  {:algorithm :aes128-cbc-hmac-sha256}))</p>
<p>;; And now, decrypt it using the same parameters: (-&gt; (crypto/decrypt encrypted key iv {:algorithm :aes128-cbc-hmac-sha256})  (codecs/bytes-&gt;str))</p>
<h2><a href="#hello-world-" name="hello-world-"></a>;; =&gt; “Hello World.”</h2>
<p>This is a complete list of supported encryption schemes:</p>
<ul>
  <li><code>:aes128-cbc-hmac-sha256</code> (default)</li>
  <li><code>:aes192-cbc-hmac-sha384</code></li>
  <li><code>:aes256-cbc-hmac-sha512</code></li>
  <li><code>:aes128-gcm</code></li>
  <li><code>:aes192-gcm</code></li>
  <li><code>:aes256-gcm</code></li>
</ul>
<p>== Paddings</p>
<p>Padding schemes are often used for fill the empty bytes of byte array of data to an concrete blocksize.</p>
<p>.This is a list of currently supported padding schemes [options=“header”] |======================================== |Algorithm name | Keywords | Zero Byte | <code>:zerobyte</code> | PKCS7 | <code>:pkcs7</code> | TBC | <code>:tbc</code> |========================================</p>
<p>Let see an example on how to use it:</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ‘[buddy.core.padding :as padding]) (require ’[buddy.core.bytes :as bytes])</p>
<p>(def data (byte-array 10))</p>
<p>;; Fill the array with byte value 10 (bytes/fill! data 10)</p>
<p>;; Add padding to the byte array with offset value: 7 ;; This is a side effect and it will mutate the data ;; byte array.</p>
<p>(vec (padding/pad! data 7 :pkcs7)) ;; =&gt;[10 10 10 10 10 10 10 3 3 3]</p>
<p>;; Also it has the side effect free version of it, that ;; returns a new byte array.</p>
<p>(vec (padding/pad data 7 :pkcs7)) ;; =&gt;[10 10 10 10 10 10 10 3 3 3]</p>
<p>;; Show the size of applied padding (padding/count data :pkcs7) ;; =&gt; 3</p>
<p>;; Remove the padding (vec (padding/unpad data 7 :pkcs7))</p>
<h2><a href="#10-10-10-10-10-10-10-0-0-0" name="10-10-10-10-10-10-10-0-0-0"></a>;; =&gt;[10 10 10 10 10 10 10 0 0 0]</h2>
<p>The default padding scheme is <code>:pkcs7</code> and that parameter can be ommited.</p>
<p>== Nonces and Salts</p>
<p>This library comes with helpers for generate random salts and cryptographically secure nonces:</p>
<p>.Generate a cryptographically secure nonce</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.nonce :as nonce])</p>
<p>(vec (nonce/random-nonce 16)) ;; =&gt; [0 0 1 75 -114 49 -91 107 67 -124 -49 -2 -96 100 42 18]</p>
<p>(vec (nonce/random-nonce 16))</p>
<h2><a href="#0-0-1-75-114-49-88-102-92-88-111-69-46-93-1-86" name="0-0-1-75-114-49-88-102-92-88-111-69-46-93-1-86"></a>;; =&gt; [0 0 1 75 -114 49 -88 -102 92 88 111 69 46 93 1 -86]</h2>
<p>The <em>random-nonce</em> function returns a byte array with minimum length of 8 bytes, because is the size of the current time in miliseconds.</p>
<p>.Generate a cryptographically secure salt</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.nonce :as nonce])</p>
<p>(vec (nonce/random-bytes 16)) ;; =&gt;[-50 20 -120 -38 -32 -121 -15 109 86 -99 85 -73 28 -92 -67 -64]</p>
<p>(vec (nonce/random-bytes 16))</p>
<h2><a href="#84-88-51-120-122-30-78-31-96-22-119-122-29-54-64-73" name="84-88-51-120-122-30-78-31-96-22-119-122-29-54-64-73"></a>;; =&gt; [84 -88 51 120 122 -30 78 -31 -96 -22 119 122 29 -54 -64 -73]</h2>
<p>Like <em>random-nonce</em> function, <em>random-bytes</em> returns a byte array but it not have the limitation of minimum 8 bytes of size.</p>
<p>== Codecs &amp; Bytes</p>
<p>This library comes with helpers for working with codecs (hex, base64, …) and byte arrays.</p>
<p>This is a brief list of available functions:</p>
<p>.Available hash algorithms [options=“header”, cols=“1,2”] |========================================================================= | Namespace/Function | Description | <code>buddy.core.codecs/str-&gt;bytes</code> | Converts a string into byte array | <code>buddy.core.codecs/bytes-&gt;str</code> | Converts byte array to string using UTF8 encoding | <code>buddy.core.codecs/bytes-&gt;hex</code> | Converts byte array to hexadecimal string | <code>buddy.core.codecs/hex-&gt;bytes</code> | Converts hexadecimal strings into byte array | <code>buddy.core.codecs/long-&gt;bytes</code> | Get byte array representation of long | <code>buddy.core.codecs/bytes-&gt;long</code> | Get long from byte array | <code>buddy.core.bytes/bytes?</code> | Predicate for test byte arrays | <code>buddy.core.bytes/fill!</code> | Fill byte array with data | <code>buddy.core.bytes/slice</code> | Create a new byte array as slice of other | <code>buddy.core.bytes/copy</code> | Copy the byte array. | <code>buddy.core.bytes/equals?</code> | Constant time equals predicate for byte arrays | <code>buddy.core.bytes/concat</code> | Concat two or more byte arrays |=========================================================================</p>
<p>== X.509 Certificates</p>
<p>Support for basic certificate handling is available in the buddy.core.certificates namespace.</p>
<p>You can load certificates, check date validity, and check to see if a certificate is signed by a known public key.</p>
<h2><a href="#source-clojure" name="source-clojure"></a>[source, clojure]</h2>
<p>(require ’[buddy.core.certificates :as certs])</p>
<p>(def cert (certs/certificate “path/to/certificate.crt”)) ;; =&gt; #object[org.bouncycastle.cert.X509CertificateHolder 0x2919034b "org.bouncycastle.cert.X509CertificateHolder@1612eab1"] (certs/valid-on-date? cert) ;; =&gt; true if today is between not-before and not-after</p>
<p>(certs/verify-signature cert (certs/certificate “path/to/ca.crt”)) ;; =&gt; true if cert is signed by public key in ca.crt</p>
<hr />
<p>== FAQ</p>
<p>=== Buddy has own cryptographic algorithms implementations?</p>
<p>Mainly no, I’m not cryptography expert and for this I rely on the to battle tested Bouncy Castle java library that’s dedicated to this purpose.</p>
<p>=== Buddy will support pgp?</p>
<p>Surely not! Because there already exists one good link:<a href="https://github.com/greglook/clj-pgp[library">https://github.com/greglook/clj-pgp[library</a> for that].</p>
<p>=== Unexpected exceptions when application is run from uberjar?</p>
<p>This is known problem of BouncyCastle. This is because, some parts of buddy uses the BC provider that BouncyCastle exposes. And any security providers for the JDK should be signed. And if you repackage all dependencies of your application in one unique jar, it will not match the signature of BC provider, and then, jdk will silently rejects adding it.</p>
<p>Take care that only very small part of buddy-core is subject to this issue. Only the <code>buddy.core.dsa</code> and <code>buddy.core.keys</code> (partially) are using the security provider. So if you are using it, you will need to provide the bouncy castle dependency separatelly to your uberjar bundle.</p>
<p>A common approach for this case, is just put <code>:uberjar-exclusions
[#"org/bouncycastle"]</code> on your <code>:uberjar</code> profile and then, download the bouncycastle jars and expose them in the classpath. If you are running your application directly from lein, you are not affected by this issue.</p>
<p>== Developers Guide</p>
<p>=== Contributing</p>
<p>Unlike Clojure and other Clojure contributed libraries <em>buddy-core</em> does not have many restrictions for contributions. Just open an issue or pull request.</p>
<p>=== Philosophy</p>
<p>Five most important rules:</p>
<ul>
  <li>Beautiful is better than ugly.</li>
  <li>Explicit is better than implicit.</li>
  <li>Simple is better than complex.</li>
  <li>Complex is better than complicated.</li>
  <li>Readability counts.</li>
</ul>
<p>All contributions to <em>buddy-core</em> should keep these important rules in mind.</p>
<p>=== Source Code</p>
<p><em>buddy-core</em> is open source and can be found on link:<a href="https://github.com/funcool/buddy-core[github]">https://github.com/funcool/buddy-core[github]</a>.</p>
<p>You can clone the public repository with this command:</p>
<h2><a href="#source-bash" name="source-bash"></a>[source,bash]</h2>
<h2><a href="#git-clone" name="git-clone"></a>git clone <a href="https://github.com/funcool/buddy-core">https://github.com/funcool/buddy-core</a></h2>
<p>=== Run tests</p>
<p>For running tests just execute this:</p>
<h2><a href="#source-bash" name="source-bash"></a>[source,bash]</h2>
<h2><a href="#lein-test-all" name="lein-test-all"></a>lein test-all</h2>
<p>=== License</p>
<p><em>buddy-core</em> is licensed under Apache 2.0 License. You can see the complete text of the license on the root of the repository on <code>LICENSE</code> file.</p></div></div></div></body></html>